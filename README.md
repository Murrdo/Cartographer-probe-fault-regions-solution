# Cartographer-probe-fault-regions-solution

Этот гайд может помочь если у вы столкнулись с тем, что картографер снимает неверный меш и у вас есть одна или несколько полос/областей более менее параллельных осям принтера с провисающим первым слоем или слоем "гармошкой", и при этом у вас нет реального перекрута осей (область дефекта поворачивается вместе с пластиной) 


<details>
  <summary>Фото  (<i>click to expand</i>)</summary>
Результат до:

![image](https://github.com/user-attachments/assets/9d96c158-fff3-453d-8174-94d98f0a32e6)


Результат после:

![image](https://github.com/user-attachments/assets/6abfd4bc-abc3-440b-85c4-f768bd32a737)

</details>


Старая версия через штатную калибровку axis_twist показала себя так себе, по какой то причине даже после неё могут оставаться проблемные области которые требуют ручной корректировки, в итоге намного быстрее и проще (и лучше результат) можно получить по печатной модели. 

1.В любом каде создаёт плоскость по размеру области мечати, делаем отступ исходя из mesh_min mesh_max и выделяем её другим цветом.  
2.Рсуем на ней примерно подобную калибровочную модель, и на ней обознаем текстом "опорные точки", число выступов для ориента должно быть нечетным с совпадать с количеством точек меша по этой же оси. Т.е. доджны совпадать с мешем - начало, середина, конец.  
3.Делаем скрин в каде, используем его как фото/текстуру стола, по этому фото позицинируем печатный тест.  
<img width="880" height="762" alt="изображение" src="https://github.com/user-attachments/assets/64e71f1d-7a2a-4592-849c-bf2ca76bfb25" />  
4.Создаём в секции, пустую болванку нулями, именно с пробелами - они сильно помогут с отстчётом точек.  
```
[axis_twist_compensation]
compensation_start_y = #MESH_MIN
compensation_end_y = #MESH_MAX
zy_compensations = 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,  0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0
```
5.Печатаем тест, ориентируясь по выступам вносит изменения в конфиге, т.е. каждое значение в массиве это локальный офсет применяемый к конкретной координате.
Получаем что-то в духе:
```
zy_compensations = -0.05,-0.05,-0.05,-0.05,-0.05,-0.05,-0.05,-0.05,-0.05,-0.05, -0.035,0,0,0,0,0,0,0,0,0, 0,0,0,0,0.02,0.035,0.055,0.055,0.055,0.055
```
Готово! Процесс занимает минут 30, обычно хватает перепечатать тест 2-4раза.  
# !!После каждого изменения в массиве zy_compensations будет меняться общий офсет, перед каждой итерацией теста его нужно будет подбирать заново в начале печати.

Самое главное, если проблемы вдоль оси Y - в klipper до сих пор есть баг из-за которого значения из массива zy_compensations применяются не к ожидаемым координатам, а со смещением в 2 расстояния между координатами точек в массиве. Перед выполнение гайда нужно отредактировать фаил:
/home/orangepi/klipper/klippy/extras/axis_twist_compensation.py
Нужно найти строку - 
```
interpolate_t = (coord - comp_start) / spacing

```
И исправить на: (готовый фаил выложить невозможно т.к. от версии к версии в нём очень многое меняетя, кроме этого бага :) 
```
interpolate_t = coord / spacing
```
После чего перезапустить сервис клиппера.

Это исправляет смещение в 2 точки по Y НО оно появится по оси X. Сори мне лень глубже вникать в эту проблему, я писал много раз об этой проблеме на форуме клиппера - игнор. 


<details>
  <summary>Старая версия гайда  (<i>click to expand</i>)</summary>

            
Возможно проблема вызвана неоднородностью "магнитных свойств" каждой конкретной пластины, у меня из 4х пластин в наличии на всех были проблемные области, при повороте пластины на 90гр область поворачивается вместе с пластиной, реального перекрута осей нет, на механическом таче результат хороший.

Идея в том, что бы использовать компенсацию перекрута осей, при том что реального перекрута может и не быть, при этом нужно производить калибровку по большому количеству точек (с шагом 5-10мм).
Но в данный момент (май 2025) в клиппере есть баг, унавледованный ещё из марлина, из-за которого происходит смещение измеренного офсета на 2 шага в минус от координат в котором он измерялся, что делает его непригодным для исправления локальных ошибок. 
Баг разрабами игнорируется (т.к. проявляется вместе с картографером что в их понимании "сторонние модификации" и в такие проблемы они вообще не вникают).

![image](https://github.com/user-attachments/assets/ccff6671-97a4-47db-b78f-5cec496cca87)



```
def _get_interpolated_z_compensation(
            self, coord, z_compensations,
            comp_start,
            comp_end
            ):

        sample_count = len(z_compensations)
        spacing = ((comp_end - comp_start)
                   / (sample_count - 1))
        interpolate_t = coord / spacing
        interpolate_i = int(math.floor(interpolate_t))
        interpolate_i = bed_mesh.constrain(interpolate_i, 0, sample_count - 2)
        interpolate_t -= interpolate_i
        interpolated_z_compensation = bed_mesh.lerp(
            interpolate_t, z_compensations[interpolate_i],
            z_compensations[interpolate_i + 1])
        return interpolated_z_compensation
```
После чего можно штатным образом сделать калибровку 
```
AXIS_TWIST_COMPENSATION_CALIBRATE AXIS=Y SAMPLE_COUNT=30
```
После чего перекалибровать модель картографера.

<details>
  <summary>Старая версия совсем ручной калибровки  (<i>click to expand</i>)</summary>


### Подготовка:

Убрать (если есть) секцию AXIS_TWIST в самом низу конфига, иначе новая калибровка будет происходить **ПОВЕРХ** уже работающего AXIS_TWIST и вы запу таетесь в результатах. 
Перезагрузить прошивку

Откалибровать модель стола картографера в ручную - 
```
CARTOGRAPHER_CALIBRATE METHOD=MANUAL
```

Перезагрузить прошивку

В любом удобном месте конфига создаём  секцию

```
[axis_twist_compensation]
#для упролщения процесса советую создать здесь "линейку" что бы было проще ориентироваться к каким координатам примениться офсет.
# Но линейку нужно спозиционировать по несколькоим точкам, т.е. например меняется несколько значений в zy_compensations на +1, перезагружаетесь
#- снимаете меш, смотрите какая точка какой координате соответствует и заполняете линейку для что бы координаты соответствовали реальным.
#-----------        20     30     40     50      60    70     80     90     100   110    120     130    140   150     160    170    180    190   200    210    220    230    240    250    260    270    280    290    300    310    320     330
zy_compensations = +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00, +0.00,
#здесь мы создаёт массив точек (офсетов) для корректировки дефекта, их количество должно быть НЕЧЁТНЫМ,
#[количество]/[max-mix]=расстояние между точками, его следует выбирать соразмерным дефективной области и крутизне её начала или конца
compensation_start_y = 
compensation_end_y = 
#координаты начала области калибровки и её конца, лучше делать во весь стол, я пробовал задавать компенсацию только
#в проблемной области но работает криво. Основной момент - точки должны быть СИММЕТРИЧНЫ относительно [bed_mesh] zero_reference_position: 164, 162 
#для конкретной оси. Тут же мы указываем ось, вдоль какой оси дефектная область - ту ось и указываем
```


#### Калибровка:

Далее наша задача любым удобным образом составить представление о проблемной области:

1.Можно просто напечатать первый слой во весь стол, снять пластину и измерить линейкой примерные координаты её начала или конца
2.Можно заранее снять качественный детальный меш механическим тачем и сравнить его с тем что выдает картографер

Например, вот результат механической пробы:

![image](https://github.com/user-attachments/assets/039616d5-30b7-47cb-916e-068304cecd38)


А это меш снимаемый картографером

![image](https://github.com/user-attachments/assets/b5398d17-9799-4240-8ee5-c1dcf52f66d5)


Сопоставляя график и проблемные области на первом слое видимо две проблемные области, первая небольшая в диапазоне Y65-Y100, вторая огромная по  Y185-Н270.

И начинаем в ручную корректировать коэффициенты в секции перекрута пересканируя стол пока не получите график близкий к механике.

Запредельной точности не нужно, отклонение в 2-3 сотки  на качестве первого слоя не сказывается.

Очень важный момент - если точка хоуминга у вас внутри проблемной области - после каждого изменения возможно есть смысл сделать ручную калибровку модели картографера, 
```
CARTOGRAPHER_CALIBRATE METHOD=MANUAL
```
 и возможно даже 
 ```
CARTOGRAPHER_THRESHOLD_SCAN
```

По завершению/перед тестовой печатью обязательно перекалибровываем модель картографера 
```
CARTOGRAPHER_CALIBRATE METHOD=MANUAL
```

Финально корректируем офсеты по реальной печати первого слоя, можно уже не во весь стол главное бы тест пересекал проблемную область.

Результат после подбора значений, дающий хороший первый слой


</details>

</details>

![image](https://github.com/user-attachments/assets/f5d1a68d-106c-4e14-a717-958b1032b12c)


Из разряда неудобств - это придеться делать под каждую проблемную пластину, а при установке беспроблемной пластины секцию перекрута нужно удалять из конфига
